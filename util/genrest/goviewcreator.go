// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package genrest

import (
	"fmt"
	"sort"
	"strings"

	"github.com/googleapis/gapic-showcase/util/genrest/gomodel"
	"github.com/googleapis/gapic-showcase/util/genrest/goview"
)

func NewView(model *gomodel.Model) (*goview.View, error) {
	view := goview.New(len(model.Shim))

	for idxShim, shim := range model.Shim {
		file := view.Append(goview.NewFile("", strings.ToLower(shim.ShortName)+".txt"))
		file.P("AUTOGENERATED STUB shim %d: %s\n(This will be replaced by a generated Go source file)\n", idxShim, shim.FullName())
		file.P("--- Imports ----------")

		namer := NewNamer()

		importStrings := make([]string, 0, len(shim.Imports))
		for _, spec := range shim.Imports {
			importStrings = append(importStrings, fmt.Sprintf("%s: %q", spec.Name, spec.Path))
		}
		sort.Strings(importStrings)
		file.P(strings.Join(importStrings, "\n"))

		file.P("\n--- Handlers ----------\n")

		for _, handler := range shim.Handlers {
			handlerName := namer.Get("Handle" + handler.GoMethod)
			file.P("//                For :%s", handler.URIPattern)
			file.P("// Match URIs of form :%s", matchingPath(handler.PathTemplate))
			file.P("func %s(w http.ResponseWriter, r *http.Request) {", handlerName)
			file.P("  // serialize from r to: var %s %s.%s", handler.RequestVariable, handler.RequestTypePackage, handler.RequestType)
			file.P("  %s := %s(%s)", handler.ResponseVariable, handler.GoMethod, handler.RequestVariable)
			file.P("  // serialize back to w\n")
			file.P("}\n")
		}

	}

	return view, nil
}

type Namer struct {
	registered map[string]int
}

func NewNamer() *Namer {
	return &Namer{registered: make(map[string]int)}
}

func (namer *Namer) Get(newName string) string {
	numSeen := namer.registered[newName]
	namer.registered[newName] = numSeen + 1
	if numSeen == 0 {
		return newName
	}
	return fmt.Sprintf("%s_%d", newName, numSeen)
}

func matchingPath(pt gomodel.PathTemplate) string {
	patterner := &patterner{root: pt}
	return patterner.Extract(pt)
}

type patterner struct {
	root           gomodel.PathTemplate
	insideVariable bool
}

func (pt *patterner) Extract(src gomodel.PathTemplate) string {
	parts := make([]string, len(src))
	for idx, seg := range src {
		var part string
		switch seg.Kind {
		case gomodel.Literal:
			part = seg.Value
		case gomodel.SingleValue:
			part = `[a-zA-Z_%\-]+`
		case gomodel.MultipleValue:
			part = `[a-zA-Z_%\-/]+`
		case gomodel.Variable:
			if !pt.insideVariable {
				pt.insideVariable = true
				part = fmt.Sprintf("{%s:%s}", seg.Value, pt.Extract(seg.Subsegments))
				pt.insideVariable = false
			} else {
				part = fmt.Sprintf("(?:%s)", pt.Extract(seg.Subsegments))
			}

		}
		parts[idx] = part

	}
	return strings.Join(parts, "")
}
